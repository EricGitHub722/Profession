1. 先要把表构建出来

2. 其次要理解什么时explain，如何分析

3. 再其次思考如何优化

4. 最后添加大量数据验证

如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置





2NF：不能由部分主键推导至其它属性

3NF：不能非主推非主

BCNF：不能非主推主

![image-20220530215415964](C:\Users\huawei\AppData\Roaming\Typora\typora-user-images\image-20220530215415964.png)

什么是数据库索引？

数据库索引其实就是为了使得查询数据效率快

为什么不使用二叉树？因为当数据量越大，二叉树的节点越多，当从根节点搜索的时候，影响查询效率。如果这些节点存储在外存储器中的话，每访问一个节点，相当于进行了一次I/O操作。

所以设计B+树就是为了解决数据量大的时候存储在外存储器时查找效率底下的问题。

### **B+树的特点**

1. 中间元素不存数据，只是充当索引，所有数据存于叶子节点当中
2. 所有中间节点在子节点中要么是最大要么是最小元素
3. 叶子节点包含所有的数据以及指向这些元素的指针，并且叶子节点的元素形成了自小向大的链表

### B+树的优势

1. 单个节点可以存储更多的数据，减少I/O的次数
2. 性能更稳定，因为都是要查找到叶子节点
3. 叶子节点形成了有序链表，便于查询

### B+树的查找方式

1. 单元素查找
2. 范围查找

单元素查找：从根节点一直查找到叶子节点，因为中间结点只是索引，不存数据。

范围查找：直接从链表查



B树概括来说是**一个节点可以拥有多于2个子节点的二叉查找树**

索引树对应着磁盘页。最坏情况下，磁盘IO次数等于索引树的高度。所以为了减少磁盘的IO次数，就需要把原本“瘦高”的树结构变得“矮胖”。这也就是B-树的特征之一。

B树是一种多路平衡查找树，它的每一个节点最多包含k个孩子，k被称为B树的阶。k的大小取决于磁盘页的大小。

下面来具体介绍一下B-树（Balance Tree），一个m阶的B树具有如下几个特征：

1. 根节点至少有两个子女
2. 每个中间节点都包含k-1个元素和k个孩子，其中m/2<=k<=m
3. 每一个叶子节点都包含k-1个元素，其中m/2<=k<=m
4. 所有的叶子结点都位于同一层
5. 每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划

![img](https://pic2.zhimg.com/80/v2-2f47deb17f430f488e91248f604a8aa1_720w.jpg)

B-树在查询中的比较次数其实不比二叉查找树少，尤其当单一节点中的元素数量很多时。可是相比磁盘IO的速度，内存中的比较耗时几乎可以忽略。所以只要树的高度足够低，IO次数足够少，就可以提升查找性能。相比之下节点内部元素多一些也没有关系，仅仅是多了几次内存交互，只要不超过磁盘页的大小即可，这就是B-树的优势之一。

B-树的一大优势：自平衡。

B+树是基于B-树的一种变体，有着比B-树更高的查询性能。

一个m阶的B+树具有如下几个特征：

1. 有k个子树的中间节点包含有k个元素（B-树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
2. 所有的叶子节点中包含了全部元素的信息，以及指向含这些元素记录的指针，且叶子节点本身依关键字的大小自小而大顺序链接。
3. 所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或者最小）元素。

另外的特征就是B-树中各个节点都存在卫星数据；而B+树中只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联。所以同样大小的磁盘页B+树比B-树容纳更多的节点元素，B+树的结构比B-树更加“矮胖”，因此查询时IO次数也更少。其次B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。因此B-树的查找性能并不稳定（分最好情况和最坏情况）。而B+树的每一次查找都是稳定的。

并且B-树的范围查询是很繁琐的，反观B+树的查询范围则要简单得多，只需在链表上做遍历即可。

综合起来B+树相对B-树的优势有：

1. IO次数更少
2. 查询性能稳定
3. 范围查询简便

至于B+树的插入和删除，过程与B-树大同小异





补充：B+ 树的阶，即内部结点中键的最小数目v。   也有些人把阶定义为内部结点中键的最大数目，即2v。



存在的问题，当阶为4，数据量为99时，生成的B+树不符合定义





### **胸+肱三**

肩部环绕30s

开合跳30s

跪姿半程俯卧撑2*8（热身）

上斜俯卧撑2*8（扶桌）

跪姿俯卧撑3*8

宽距俯卧撑1*6

跪姿俯卧撑or俯卧撑2*6

左侧胸大肌拉伸30s

右侧胸大肌拉伸30s

左臂肱三头肌拉伸30s

右臂肱三头肌拉伸30s

### **腹部**

平板支撑30s

卷腹摸膝1*10

屈膝收腹1*15

支撑侧提膝1*16

腹肌拉伸30s

西西里卷腹1*8

屈膝收腹1*8

支撑侧提膝1*12

腹肌拉伸30s

### **手臂+肩**

肩部环绕30s

开合跳30s

哑铃弯举1*8（热身）

哑铃推举1*8（热身）

哑铃单臂弯举1*8

哑铃推举1*8

哑铃前平举1*12

哑铃侧平举1*8

哑铃单臂弯举1*8

哑铃推举1*8

哑铃前平举1*12

哑铃侧平举1*8

左侧肱二头肌拉伸30s

右侧肱二头肌拉伸30s

左侧肩部拉伸30s

右侧肩部拉伸30s



```C++
(1) 如果删除后叶子结点填充度仍>=50%，只需要修改叶子结点，如果删除的是父结点的键，父结点也要相应修改；
(2) 如果删除后叶子结点填充度<50%，需要先找到一个最近的兄弟结点(左右均可)，然后分两种情况：
    A. 如果该兄弟结点填充度>50%，把该兄弟结点的最近一个数据剪切到本结点，父结点的键值也要相应修改。
    B. 如果该兄弟结点的填充度=50%，则把两个结点合并，父结点键也相应合并。(如果合并后父结点的填充度<50%，则需要递归)
```







